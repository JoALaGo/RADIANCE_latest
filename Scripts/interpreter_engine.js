//This is a rudimentary version of the interpreter. It will only contemplate the basic features of the BBCP, excluding the parameters
//available in the initialization section of Radiance
//For now it will only include pseudocode and some plantuml diagrams to guide myself
//----------- (L) labels-----
//WARNING: features that are currently rudimentary and should be improved
//------------(A) Simulation requisites-----------------
//Variables: 
// var initialized_profiles = new Object(); <-- to store all the profiles that will be used during the simulation
// var evaluate_profiles= []; <---- an array with the profiles to evaluate at a specific point in time.
// var cooldown_profiles= []; <---- an array with the profiles in cooldown (can't be evaluated)
// var lock_minimum_run= []; <---- an array with the profiles that are locked in a run state due to the minimum run time definition
// var external_parameter_pool = []; <---- to store all the parameters that are generated by the operations (external parameters only).
// var resource_usage = [{profile_id:'',resource_usage:{ram:'',cpu:''...}}]
// var seconds_left = N; <---- to control the seconds left in the simulation.
var initialized_profiles = new Object();
var evaluate_profiles = new Object();
var cooldown_profiles = new Object();
var lock_minimum_run = new Object();
var external_parameter_pool = new Object();
var resource_usage = new Object();
var seconds_left = 0;
var current_second = 1;
var log = '';
var simulation_dataset = new Object();
var run_plot = null;
var simulations = [];
var log_reporting_active = true;
var mock_plot = null;

//to achieve certain states: 
/*
R = run
S = stop
L = locked
Lm = locked for minimum run time
C = cooldown
Aq = A valid quota
E= can be evaluated
--------------------------
Important axioms:
--------------------------
minimum run time spends time from the quota.

Lm -> R^~E: Profiles locked for a minimum run time are in a run state and can not be evaluated
E -> ~Lm^~L^~C
R -> Aq^E^~Lm^~C
C-> ~E^~Lm^~R




//code conventions for the bounds of certain values in the profiles:
--------------------------------------------------------------------

Every range should start from 1. For instance, a range selection or day selection should always start in 1 not 0. This is to avoid confusion with the 0 index in arrays against
the 1 index in the profile's configuration for selections of days and ranges.
*/

function printToLog(message, type) {

    if (this.log_reporting_active) {
        log += "<br>";
        if (type == 'message') {
            log += ">" + message;
        } else {
            log += '' + message + '';
        }
    }



}
//------------- (C) Seconds subroutines-----------------
// 
// - Verify that the instant run time does not exceed the maximum run time, but respects the minimum run time
// - Verify that the profiles under an evaluation_lock have a (B) current_cooldown lower than the profile's cooldown
//
//
//----------STEP 1--------------
//
// We get a list of all the profiles included in the collection with no duplicates
function interpreterEngineInitialization() {
    console.time('Simulation');
    console.log("Initializing the interpreter");
    //we clear the log 
    let log = document.getElementById('interpreter_simulation_log').innerHTML = '';
    this.log = '';
    log.innerHTML = '';
    this.initialized_profiles = new Object();
    this.evaluate_profiles = new Object();
    this.cooldown_profiles = new Object();
    this.lock_minimum_run = new Object();
    this.external_parameter_pool = new Object();
    this.resource_usage = new Object();
    this.seconds_left = document.getElementById("interpreter_time_initialization").value;
    this.current_second = 1;//we always start in second 1
    var simulation_id = Date.now();
    var results_dataset = this.simulation_dataset[simulation_id] = {};
    this.simulation_dataset[simulation_id].run_stamps = {};
    this.simulation_dataset[simulation_id].stop_stamps = {};
    this.simulation_dataset[simulation_id].delta_quota = {};
    let log_reporting_active = false;
    simulations.push(simulation_id);

    //we get all the profiles of the collections for the interpreter
    //WARNING: Right now as a rudimentary implementation I will only care about 1 collection, it should be improved to search through all the collections and initialize the profiles needed
    let collection = getInstanceFromDb('collection', this.db.test_tube.collections[0].root_id);
    printToLog('Interpreter initialized', 'message');
    for (let x in collection.inner_profiles) {

        let profile_instance = getInstanceFromDb('profile', collection.inner_profiles[x]);
        console.log(JSON.stringify(profile_instance));
        //console.log('initializing ' + profile_instance.element_name + " profile", 'message');
        printToLog('initializing ' + profile_instance.element_name + " profile", 'message');
        this.simulation_dataset[simulation_id].run_stamps[profile_instance.element_id] = [];
        // We create an object called "initialized profiles"
        //  - Each profile initialization should be included in initialized profiles as properties, so that the lookoup is quick.
        // Result: initialized_profiles.1826108287[bbcp properties]
        //                             .8578611278[bbcp properties]
        //The [bbcp properties] are the parsed profiles cache of each profile
        this.initialized_profiles[collection.inner_profiles[x]] = JSON.parse(profile_instance.profile_cache);
        printToLog('<p style="color:green">success</p>', 'state');
        //(B) Each profile should have the following properties assigned to them for the simulation, and the pertinent values initialized: 
        /* The places in the initialization for each property
            0. Profile_configuration
            1. Computation_centric
            2. Data_centric
            3. Conduct_centric
            4. Usage
            5. Run_constraints
            6. Expectations
            7. Cycles
            8. Timed_expectations
            9. Elasticity
            10. Run_constraints
            11. Events
            12. Timed_expectations
            13. Elasticity
            14. Run_constraints
            15. Operations
            16. resource_usage
            17. Run_constraints
            18. Operation_run_constraints
            19. Parameters
            20. Dependencies
            21. Operational
            22. Triggers
            23. Results
            */

        //  - delta_quota: to track the dyanamic quota; the quota that changes throughout the simulation.
        let current_obj = this.initialized_profiles[collection.inner_profiles[x]];
        current_obj['profile_name'] = getInstanceFromDb('profile', collection.inner_profiles[x]).element_name;
        current_obj['engine_variables'] = {};
        current_obj.engine_variables['delta_quota'] = parseInt(current_obj[5][1].quota);
        //  - current_cooldown: to track the cooldown during the simulation
        current_obj.engine_variables['delta_cooldown'] = current_obj[5][1].cooldown;
        //  - delta_evaluation: this will be the variable used to sum every value per evaluation until n mod 1 = 0, which give us the signal to evaluate
        current_obj.engine_variables['delta_evaluation'] = 0;
        //  - delta_instant_run_time: this will track the time that the profile has spent in a run time
        current_obj.engine_variables['delta_instant_run_time'] = 0;
        //  - current_state: to trace the state; true for run false for stop 
        current_obj.engine_variables['current_state'] = false;
        //  - delta_run_probability: to trace the change in run probability
        current_obj.engine_variables['delta_run_probability'] = current_obj[4][1].run_base_probability;
        //  - delta_stop_probabilit: to trace the change in stop probability
        current_obj.engine_variables['delta_stop_probability'] = current_obj[4][1].stop_base_probability;
        //  - delta_elasticity: to trace the change in elasticity according to timed expectations
        current_obj.engine_variables['delta_elasticity'] = 0;
        //  - delta_evaluation_counter: this will count the number of evaluations elapsed in the last state
        current_obj.engine_variables['delta_evaluation_counter'] = 0;
        //  - delta_elastic_evaluation_counter: this will count the number of evaluations elapsed in the last state under elasticity
        current_obj.engine_variables['delta_elastic_evaluation'] = 0;
        //  - delta_accumulated_run: this variable sums up all the time that the profile has spent in a run time "naturally": with no policy enforcement from either the minimum run time or the quota
        current_obj.engine_variables['delta_accumulated_run'] = 0;
        current_obj.engine_variables['delta_enforced_accumulated_run'] = 0;
        //  - parameter_pool: this variable stores a quantity of pararmeter types generated {type:'parameter_id',quantity:'N'}
        current_obj.engine_variables['parameter_pool'] = [];
        //  - last_run: the time that has elapsed since the last run
        current_obj.engine_variables['last_run'] = 0;
        //  - evaluation_lock: it locks the profile in the state and avoids the profile from being evaluated
        current_obj.engine_variables['evaluation_lock'] = false;
        //  - current_cycle: to store the current cycle that the profile is in
        current_obj.engine_variables['current_cycle'] = null;
        //  - current_timed_expectation: to store the current timed expectation that the profile is in
        current_obj.engine_variables['current_timed_expectations'] = null;
        //  - in this variable 
        current_obj.engine_variables['legacy_run_constraints'] = JSON.parse(JSON.stringify(current_obj[5][1]));
        



        //now we optimize the search for each instance of: operations, cycles, events, timed expectations etc. by passing them from an array to an object
        //optimize operations
        current_obj.engine_variables['operations'] = new Object();
        console.log("Optimizing operations in: " + collection.inner_profiles[x]);
        for (let x in current_obj[15][4]) {
            current_obj.engine_variables.operations[current_obj[15][4][x].inner_id] = current_obj[15][4][x];
        }

        //optimize cycles
        current_obj.engine_variables['cycles'] = new Object();
        console.log("Optimizing cycles in: " + collection.inner_profiles[x]);
        for (let x in current_obj[7][4]) {
            current_obj.engine_variables.cycles[current_obj[7][4][x].inner_id] = current_obj[7][4][x];
        }
        //optimize the timed expectations that belong to cycles
        current_obj.engine_variables.cycles['timed_expectations'] = new Object();
        console.log("Optimizing timed expectations for each cycle in: " + collection.inner_profiles[x]);
        for (let x in current_obj[7][4]) {
            //iterate over the available cycles
            current_obj.engine_variables.cycles[current_obj[7][4][x].inner_id].timed_expectations = new Object();
            //for each cycle found, register its timed expectations
            for (let y in current_obj[8][4]) {
                if (current_obj[8][4][y].parent_instance_id == current_obj[7][4][x].inner_id) {
                    current_obj.engine_variables.cycles[current_obj[7][4][x].inner_id].timed_expectations[current_obj[8][4][x].inner_id] = current_obj[8][4][x];
                }

            }
        }
        console.log(JSON.stringify(current_obj.engine_variables.cycles));

        //optimize events
        current_obj.engine_variables['events'] = new Object();
        console.log("Optimizing events in: " + collection.inner_profiles[x]);
        for (let x in current_obj[11][4]) {
            current_obj.engine_variables.events[current_obj[11][4][x].inner_id] = current_obj[11][4][x];
        }

        //optimize the timed expectations that belong to events
        current_obj.engine_variables.events['timed_expectations'] = new Object();
        console.log("Optimizing timed expectations for each event in: " + collection.inner_profiles[x]);
        for (let x in current_obj[11][4]) {
            //iterate over the available events
            current_obj.engine_variables.events[current_obj[11][4][x].inner_id].timed_expectations = new Object();
            //for each event found, register its timed expectations
            for (let y in current_obj[12][4]) {
                if (current_obj[12][4][y].parent_instance_id == current_obj[11][4][x].inner_id) {
                    current_obj.engine_variables.events.timed_expectations[current_obj[12][4][x].inner_id] = current_obj[12][4][x];
                }

            }
        } //we have to optimize operational paths. To do this, we have to create the logic of execution for each operation and repeat it each time that the operation is called, instead of obtaining the logic of execution on call.

    }

    runEngine(simulation_id);
}

function checkTime(seconds) {
    var current_day = Math.floor(seconds / (3600 * 24));
    var current_hour = Math.floor(seconds % (3600 * 24) / 3600);

    return { day: current_day, hour: current_hour };
}

function runEngine(simulation_id) {
    printToLog('Starting the engine with ' + this.seconds_left + ' seconds left');
    let total_seconds = parseInt(this.seconds_left);
    this.simulation_dataset[simulation_id].time_initialization = total_seconds;
    let run_stamps = this.simulation_dataset[simulation_id].run_stamps;
    var check_cycles = false;
    for (let x = 1; x <= total_seconds; x++) {
        //---------STEP 1----------------
        //we check the time to apply the respective expectations
        var current_time;

        if ((x % 3600) == 0) {
            current_time = checkTime(x);
            //current_time has .day and .hour
            //we can also trigger a check of the timed expectations to optimize the search i.e.: The search for valid timed expectations will only happen when the hour changes.
            check_cycles = true;
        }

        //---------STEP 2----------------
        //We get all the profiles that have run probabilities, because they are the ones that will be evaluated, we place them in (A) EVALUATE_PROFILES
        //Now that we know which profiles to evaluate, we start the evaluation, checking each  second:
        // 1- add the evaluation rate to each (B) EVALUATION_DELTA of each profile IF the profile is not in (A) COOLDOWN_PROFILES AND (A)LOCK_MINIMUM_RUN; the evaluation_lock should be false
        //      1.1- at the time of adding to the evaluation rate we check if n mod 1 = 0, if it does we put the id of the profile to evaluate in (A) EVALUATE_PROFILES
        for (let y in Object.entries(this.initialized_profiles)) {
            let entry = Object.entries(this.initialized_profiles)[y][0];

            if (check_cycles) {
                let valid_cycle = cycle_check(this.initialized_profiles[entry], current_time);
                if (valid_cycle === 'error') {
                    printToLog("Error in the cycle data for " + entry + " at " + x, "%c:red");
                    alertify.alert('<h5 class="modal-title">Error in the definition of Cycles</h5>', 'One or more of your Cycles are incorrectly set up, possibly empty. Information Dump: <div class="overflow-auto content_box"><br> <p>'+JSON.stringify(this.initialized_profiles[entry].engine_variables.cycles)+'</p></div>', function(){ alertify.error('Simulation interrupted'); });
                    console.log("Error in the cycle data for " + entry + " at " + x);
                    return;
                } else if (valid_cycle == null) {
                    printToLog("No valid cycle found for " + entry + " at " + x);
                    this.initialized_profiles[entry].engine_variables.current_cycle = null;
                } else {
                    //a valid cycle exists. We have to check if there is a timed expectation that applies.
                    //we store the valid cycle in the engine variables
                    printToLog("Valid cycle found for " + entry + " at " + x + " day: " + current_time.day);
                    this.initialized_profiles[entry].engine_variables.current_cycle = valid_cycle.current_cycle.inner_id;
                    // we can now check for timed expectations
                    let valid_timed_expectations = timed_expectations_check(this.initialized_profiles[entry], valid_cycle.current_cycle.inner_id, current_time);
                    console.log(JSON.stringify(valid_timed_expectations));
                    if (valid_timed_expectations === 'error') {
                        printToLog("Error in the cycle data for " + entry + " at " + x, "%c:red");
                        console.log("Error in the cycle data for " + entry + " at " + x);
                        return;
                    } else if (valid_timed_expectations == null) {
                        printToLog("No valid timed expectation found for " + entry + " at " + x);
                        console.log("No valid timed expectation found for " + entry + " at " + x);
                        this.initialized_profiles[entry].engine_variables.current_timed_expectations = "failed";
                    } else {
                        let entry_instance = this.initialized_profiles[entry];
                        let engine_variables = entry_instance.engine_variables;
                        printToLog("Valid timed expectation found for " + entry + " at " + x);
                        console.log("Valid timed expectation found for " + entry + " at " + x);
                        engine_variables.current_timed_expectations = valid_timed_expectations;
                        
                    }
                }


            }
            check_cycles = false;


            if (!this.cooldown_profiles.hasOwnProperty(entry) && !this.lock_minimum_run.hasOwnProperty(entry)) {
                let entry_instance = this.initialized_profiles[entry];
                let engine_variables = entry_instance.engine_variables;
                let cycles = this.initialized_profiles[entry][7];
                //we increment the delta_run_time if it was in a run state
                if (engine_variables.current_state == true) {
                    //We check that the countdown has not been violated
                    if(engine_variables.delta_instant_run_time>=entry_instance[5][1].countdown&& entry_instance[5][1].countdown!=0&&entry_instance[5][1].countdown!=""&&entry_instance[5][1].countdown!=null){
                        cascadeStopEffects(run_stamps, entry, engine_variables.delta_instant_run_time, x);
                    }else{
                    //PRE-EVALUATION RUN
                    //printToLog('instant run time: '+ engine_variables.delta_instant_run_time);
                    engine_variables.delta_instant_run_time = engine_variables.delta_instant_run_time + 1;
                    engine_variables.delta_accumulated_run = engine_variables.delta_accumulated_run + 1;

                    //we check the quota to avoid an empty quota from passing this point
                    checkQuota(entry, x, run_stamps);

                    //we check the maximum run time
                    //------CAUTION: to properly implement timed expectations we have to change the meta parameters, meaning that the values of the time constraints can not depend on the root values in "Usage". As a quick patch, we can replace the object holding the values for the time constraints with the object holding the time constraints for the timed expectation, and change them on the fly.
                    //Countdown has preference over the maximum run time.
                    if(entry_instance[5][1].countdown==0||entry_instance[5][1].countdown==""||entry_instance[5][1].countdown==null){
                        if (entry_instance[5][1].maximum_run_time > 0 && engine_variables.delta_instant_run_time >= entry_instance[5][1].maximum_run_time) {
                            //we switch the profile to a stop state
                            printToLog('<img src="./res/max_run_icon" style="max-width:25px;">  | Maximum run time reached for ' + entry + ' at ' + x, 'state');
                            cascadeStopEffects(run_stamps, entry, engine_variables.delta_instant_run_time, x);
                        }
                    }else{
                        printToLog('<img src="./res/max_run_icon" style="max-width:25px;">  | Maximum run time ignored due to countdown for ' + entry + ' at ' + x, 'state'); 
                    }
                    
                }
                } else {//the profile is in a stop state
                    engine_variables.delta_instant_run_time = 0;

                }

                //we increment delta evaluation

                entry_instance.engine_variables.delta_evaluation += + parseFloat(entry_instance[4][1].profile_evaluation_rate);
                //printToLog("delta evaluation: " + entry_instance.engine_variables.delta_evaluation + "at: " + x);

                if (entry_instance.engine_variables.delta_evaluation >= 1) {
                    printToLog('<img src="./res/search_icon.png" style="max-width:20px;">   | EVALUATION for ' + entry + " delta evaluation: " + entry_instance.engine_variables.delta_evaluation + "at: " + x);
                    this.evaluate_profiles[entry] = null;
                    entry_instance.engine_variables.delta_evaluation = entry_instance.engine_variables.delta_evaluation - 1;
                    if (entry_instance.engine_variables.delta_evaluation <= 0) {
                        //we enter a cooldown state
                        entry_instance.engine_variables.evaluation_lock = true;
                    }
                } else {
                    //printToLog('no evaluation for '+entry+" delta evaluation: "+entry_instance.engine_variables.delta_evaluation);
                    //we do not evaluate
                }

            } else {
                // this else was entered because either:
                // 1- the profile is in a cooldown (C)
                // 2- the profile is locked in a minimum run (Lm)
                let entry_instance = this.initialized_profiles[entry];
                let engine_variables = entry_instance.engine_variables;
                //we check if the current profile is either in a cooldown or locked in a minimum run
                if (this.cooldown_profiles.hasOwnProperty(entry)) {
                    //Countdown precedes the priority of the minimum run time and the cooldown.
                    if(engine_variables.delta_instant_run_time>=entry_instance[5][1].countdown&& entry_instance[5][1].countdown!=0&&entry_instance[5][1].countdown!=""&&entry_instance[5][1].countdown!=null){
                        cascadeStopEffects(run_stamps, entry, engine_variables.delta_instant_run_time, x);
                         //reinitialize the cooldown
                         engine_variables.delta_cooldown = parseInt(this.initialized_profiles[entry][5][1].cooldown);
                         //bring the profile out of lock
                         engine_variables.evaluation_lock = false;
 
                         //we take the profile out of the cooldown object and off the lock_minimum_run object just in case..
                         delete this.cooldown_profiles[entry];
                         delete this.lock_minimum_run[entry];//in case the profile was in a lock minimum run before entering the cooldown
                         printToLog("Profile's " + entry + ' countdown reached at ' + x, 'state');

                    }else{
                    if (engine_variables.delta_cooldown > 0) {
                        engine_variables.delta_cooldown = engine_variables.delta_cooldown - parseInt(1);
                        printToLog('<img src="./res/cooldown_icon.png" style="max-width:20px;">Profile ' + entry + ' in cooldown,  ' + engine_variables.delta_cooldown + ' seconds left');
                    } else {
                        //we reinitialize the quota
                        engine_variables.delta_quota = parseInt(this.initialized_profiles[entry][5][1].quota);
                        //reinitialize the cooldown
                        engine_variables.delta_cooldown = parseInt(this.initialized_profiles[entry][5][1].cooldown);
                        //bring the profile out of lock
                        engine_variables.evaluation_lock = false;

                        //we take the profile out of the cooldown object and off the lock_minimum_run object just in case..
                        delete this.cooldown_profiles[entry];
                        delete this.lock_minimum_run[entry];//in case the profile was in a lock minimum run before entering the cooldown
                        printToLog("Profile's " + entry + ' quota renewed at ' + x, 'state');
                    }
                }

                } else if (this.initialized_profiles[entry][5][1].minimum_run_time > 0 && engine_variables.delta_instant_run_time < this.initialized_profiles[entry][5][1].minimum_run_time) {
                    //Lm -> R^~E: Profiles locked for a minimum run time are in a run state and can not be evaluated
                    //we are in a minimum run time lock
                    engine_variables.delta_instant_run_time = engine_variables.delta_instant_run_time + 1;
                    engine_variables.delta_enforced_accumulated_run = engine_variables.delta_enforced_accumulated_run + 1;
                    printToLog('<img src="./res/minimum_run_lock.png" style="max-width:20px;"> Profile ' + entry + ' locked for minimum run time at ' + x + ' with ' + (parseInt(this.initialized_profiles[entry][5][1].minimum_run_time)-parseInt(engine_variables.delta_instant_run_time)) + '/' + this.initialized_profiles[entry][5][1].minimum_run_time + ' seconds ', 'state');
                    //apply the constrainst in the quota
                    checkQuota(entry, x, run_stamps);

                } else if (this.initialized_profiles[entry][5][1].minimum_run_time >= engine_variables.delta_instant_run_time) {
                    // we remove the minimum run time lock
                    delete this.lock_minimum_run[entry];
                    engine_variables.delta_instant_run_time++;
                    
                }
            }
            
        }

        //---------STEP 3----------------
        //  1- we grab each profile in (A) EVALUATE_PROFILES and we check their state
        //      1.1- We check the (B) delta profile's run or stop probability and
        //      1.2- We check against a random number if we should switch to a stop or run.

        for (let y in Object.entries(this.evaluate_profiles)) {
            let probability = 0;
            let target_state;
            //console.log(x);
            //console.log(JSON.stringify(this.evaluate_profiles));
            //console.log(Object.entries(this.evaluate_profiles)[x]);
            //console.log(Object.entries(this.evaluate_profiles)[x][0]);
            let entry = Object.entries(this.evaluate_profiles)[y][0];
            if (this.initialized_profiles[entry].engine_variables.current_state == false) {
                probability = this.initialized_profiles[entry].engine_variables.delta_run_probability;
                target_state = true;//The profile enters a run state on a successful flip
            } else {
                
              
                    probability = this.initialized_profiles[entry].engine_variables.delta_stop_probability;
                    target_state = false;//The profile enters a stop state on a succesful flip
                
                
            }
            //cooldown forces the state of the profile to a run state. I enforced it this way because instant run time will never be less than countdown unless countdown exists.
            if(this.initialized_profiles[entry].engine_variables.delta_instant_run_time<this.initialized_profiles[entry][5][1].countdown){
                target_state = true;
                probability=100;
            }

            let flip = Math.random(0, 1);
            //printToLog("flip: "+flip+" probability: "+probability+" target state: "+target_state);
            let engine_variables = this.initialized_profiles[entry].engine_variables;
            if (flip <= probability) {
                engine_variables.current_state = target_state;
                if (target_state == false) {
                    //we switch the profile to a stop
                    //We log the stop to graph it later
                    cascadeStopEffects(run_stamps, entry, (engine_variables.delta_instant_run_time - 1), x);
                    engine_variables.delta_instant_run_time = 0;

                } else {
                    cascadeRunEffects(entry, x);
                }

            }
        }

        //we remove the profile from the evaluation object AFTER everything gets evaluated, otherwise the object updates and the index stated by X becomes undefined
        this.evaluate_profiles = new Object();




    }//end of the simulation

    engineEnd();

}


function engineEnd(error) {
    if(error == null){
        console.timeEnd('Simulation');
        //we print the messages to the log
        printToLog('<h5 style="color:green">Simulation ended successfully</h5>', 'state');
        for (let x in Object.entries(this.initialized_profiles)) {
            let entry = Object.entries(this.initialized_profiles)[x][0];
            let instance = getInstanceFromDb('profile', entry);
            printToLog('The profile ' + instance.element_name + ' spent ' + this.initialized_profiles[entry].engine_variables.delta_accumulated_run + ' seconds in a natural run state.', 'message');
            printToLog('The profile ' + instance.element_name + ' spent ' + this.initialized_profiles[entry].engine_variables.delta_enforced_accumulated_run + ' seconds in an enforced run state.', 'message');
            printToLog('The profile ' + instance.element_name + ' spent ' + (Number(this.initialized_profiles[entry].engine_variables.delta_accumulated_run) + Number(this.initialized_profiles[entry].engine_variables.delta_enforced_accumulated_run))+ ' seconds running in total.', 'message');
        }
        if (this.log_reporting_active) {
            document.getElementById('interpreter_simulation_log').innerHTML += log;
        }
    
    
        //we run the plotter
        runPlotInitialization()
    }else{
        alertify.error('An error occurred during the simulation: '+error);
    }
    

}

function cascadeRunEffects(profile_id, time) {
    this.initialized_profiles[profile_id].current_state = true;
    // if the profile has a minimum run time, we have to enforce it by locking it
    //countdown has preference over the minimum run time
    if(this.initialized_profiles[profile_id][5][1].countdown>0&&entry_instance[5][1].countdown!=""&&entry_instance[5][1].countdown!=null){
        printToLog('<h6 style="color:green;">' + profile_id + ' countdown is being enforced ' + this.initialized_profiles[profile_id][5][1].minimum_run_time + '</h6>');
    }else{
        if (this.initialized_profiles[profile_id][5][1].minimum_run_time > 0) {
            this.lock_minimum_run[profile_id] = null;
            printToLog('<h6 style="color:green;">' + profile_id + ' locked to a minimum run time of ' + this.initialized_profiles[profile_id][5][1].minimum_run_time + '</h6>');
        }
    }
    
    printToLog('<h6 style="color:green;"><img src="./res/run_icon.PNG" style="max-width:20px;">' + profile_id + ' runs at: ' + time + '</h6>');
}
function cascadeStopEffects(run_stamps, profile_id, delta_instant_run_time, time) {
    printToLog('<h6 style="color:red;"><img src="./res/stop_icon.png" style="max-width:20px;">' + profile_id + ' Stopped after: ' + (parseInt(delta_instant_run_time)) + ' seconds at' + time + '</h6>');
    //console.log("cascadeStopEffects: stopped after "+delta_instant_run_time+" at "+time);
    if (delta_instant_run_time != -1) { run_stamps[profile_id].push({ 'spent': delta_instant_run_time, 'until': time - 1 }); }
    this.initialized_profiles[profile_id].engine_variables.current_state = false;
    this.initialized_profiles[profile_id].engine_variables.delta_instant_run_time = 0;


}

function checkQuota(profile_id, time, run_stamps) {
    let entry_instance = this.initialized_profiles[profile_id];
    let engine_variables = entry_instance.engine_variables;
    //we check if there was a quota assigned to the initialized profile
    if (this.initialized_profiles[profile_id][5][1].quota >= 0) {

        //a quota exists and we have to decrease delta quota
        if (this.initialized_profiles[profile_id].engine_variables.delta_quota > 0) {
            this.initialized_profiles[profile_id].engine_variables.delta_quota = this.initialized_profiles[profile_id].engine_variables.delta_quota - 1; ""
            printToLog('<img src="./res/quota.png" style="max-width:20px;">    quota decreased at ' + time + ', current quota: ' + this.initialized_profiles[profile_id].engine_variables.delta_quota);
            if (this.initialized_profiles[profile_id].engine_variables.delta_quota == 0) {
                //hey we spent the quota in this last second, we have to switch the profile to a stop state
                printToLog('<img src="./res/empty_quota.png" style="max-width:20px;">   |Profile ' + profile_id + ' spent all its quota at ' + time, 'state');
                cascadeStopEffects(run_stamps, profile_id, this.initialized_profiles[profile_id].engine_variables.delta_instant_run_time, time);
                //we are in an empty quota mode
                //lock the profile
                this.initialized_profiles[profile_id].evaluation_lock = true;
                //switch the profile to a stop state
                //place the locked profile in the cooldowned profiles object
                this.cooldown_profiles[profile_id] = null;
                if (this.initialized_profiles[profile_id].engine_variables.delta_cooldown > 0) {

                    if (!this.cooldown_profiles.hasOwnProperty(profile_id)) {
                        this.cooldown_profiles[profile_id] = null;
                        // if Lm, we switch to C-> ~E^~Lm^~R
                        if (this.lock_minimum_run.hasOwnProperty(profile_id)) {
                            delete this.lock_minimum_run[profile_id];
                        }
                    }
                    // we decrease the cooldown !---Not used as we should not contabilize the second at wich the cooldown is counted--!
                    //this.initialized_profiles[profile_id].engine_variables.delta_cooldown = this.initialized_profiles[profile_id].engine_variables.delta_cooldown - 1;
                    printToLog('current cooldown = ' + this.initialized_profiles[profile_id].engine_variables.delta_cooldown);
                }
            }
        }

    }
}


function cycle_check(profile, current_time) {
    //CYCLE CHECK
    //We verify that the current profile has cycles
    if (profile.engine_variables.cycles != null) {
        //there could be an applicable cycle here
        //we check the available cycles for the profile in the current day
        for (let current_cycle_key in profile.engine_variables.cycles) {
            if (current_cycle_key !== 'timed_expectations') {//we check that the key is not the key to another set of entities
                let current_cycle = profile.engine_variables.cycles[current_cycle_key];
                //we check if the cycle is active
                //we parse the string cointainting the days data. Days will always allow for a selection of days [1,3,5] or a selection and ranges [1-10,15,20-30].
                let regex = /^\[\d+(?:-\d+)?(?:,\d+(?:-\d+)?)*\]$/;
                let current_cycle_day_data = current_cycle.inner_variables[0].variables.Days;
                if (regex.test(current_cycle_day_data)) {
                    //the data complies with the regex format, we can extract all the ranges and selections of days.

                    //extract the dashes from the current data and check if the current day is in the range

                    // Remove brackets
                    let cleanedString = current_cycle_day_data.replace(/[\[\]]/g, '');
                    // Split by commas
                    let segments = cleanedString.split(',');

                    let result = [];

                    segments.forEach(segment => {
                        // Check if segment is a range
                        if (segment.includes('-')) {
                            let [start, end] = segment.split('-').map(Number);
                            for (let i = start; i <= end; i++) {
                                result.push(i);
                            }
                        } else {
                            // If not a range, just add the single number
                            result.push(Number(segment));
                        }
                    });

                    //check if the current day is in the selection of the cycle
                    if (result.includes(current_time.day)) {
                        return { current_cycle_day_data: result, current_cycle: current_cycle };
                    } else {
                        return null;
                    }




                } else {
                    //The data of the current_cycle_day_data is non-compliant
                    return 'error';
                }
            }
        }
    } else {
        //no cycles for the profile
        //console.log("No valid cycle found for"+entry+" at "+x);
        return null;
    }
}

function timed_expectations_check(profile, valid_cycle_id, current_time) {

    //CYCLE CHECK
    //We verify that the current profile has cycles
    //console.log(JSON.stringify(profile.engine_variables.cycles));
    if (profile.engine_variables.cycles[valid_cycle_id].timed_expectations != null) {
        //there could be an applicable cycle here
        //we check the available cycles for the profile in the current day
        for (let current_timed_expectation_key in profile.engine_variables.cycles[valid_cycle_id].timed_expectations) {
            if (current_timed_expectation_key !== 'timed_expectations') {//we check that the key is not the key to another set of entities
                let current_timed_expectations = profile.engine_variables.cycles[valid_cycle_id].timed_expectations[current_timed_expectation_key];
                //console.log(JSON.stringify(current_timed_expectations));
                //we check if the cycle is active
                //we parse the string cointainting the days data. Days will always allow for a selection of days [1,3,5] or a selection and ranges [1-10,15,20-30].
                let regex = /^\[\d+(?:-\d+)?(?:,\d+(?:-\d+)?)*\]$/;
                let current_timed_expectations_bound_data = current_timed_expectations.inner_variables[0].variables.time_range;
                //console.log(current_timed_expectations_bound_data);
                if (regex.test(current_timed_expectations_bound_data)) {
                    //console.log("Does the timed expectation apply?" + current_timed_expectations_bound_data + " at " + current_time.hour);
                    //the data complies with the regex format, we can extract all the ranges and selections of days.
                    // Remove brackets
                    let cleanedString = current_timed_expectations_bound_data.replace(/[\[\]]/g, '');
                    // Split by commas
                    let segments = cleanedString.split(',');

                    let result = [];

                    segments.forEach(segment => {
                        // Check if segment is a range
                        if (segment.includes('-')) {
                            let [start, end] = segment.split('-').map(Number);
                            for (let i = start; i <= end; i++) {
                                result.push(i);
                            }
                        } else {
                            // If not a range, just add the single number
                            result.push(Number(segment));
                        }
                    });

                    //check if the current day is in the selection of the cycle
                    console.log("Debugging timed expectations: " + current_time.hour + " in " + JSON.stringify(result)+"test case: "+ result.includes(current_time.hour));
                    if (result.includes(current_time.hour)) {
                        return current_timed_expectations.inner_id;
                    } else {
                        return null;
                    }

                } else {
                    //The data of the current_cycle_day_data is non-compliant
                    return 'error';
                }
            }
        }
    } else {
        //no cycles for the profile
        //console.log("No valid cycle found for"+entry+" at "+x);
        return null;
    }

}

function runPlotInitialization() {
    if (this.mock_plot == null) {
        /*  const layout = {
             xaxis: {range: [1, total_time], title: "Time Elapsed"},
             yaxis: {range: [0, 1], title: "Profile state"},
             title: "Profiles' states change over time"
           }; */
        console.log('lab plotter initialized');
        //we get the data for the plot

        //we get the latest simulation dataset in the array
        var trace1 = {

            x: [1, 2, 3, 4],

            y: [10, 15, 13, 17],

            mode: 'markers'

        };


        var trace2 = {

            x: [2, 3, 4, 5],

            y: [16, 5, 11, 9],

            mode: 'lines'

        };


        var trace3 = {

            x: [1, 2, 3, 4],

            y: [12, 9, 15, 12],

            mode: 'lines+markers'

        };


        var data = [trace1, trace2, trace3];


        var layout = {

            title: 'Engine results'

        };

        if (this.mock_plot != null) {
            this.mock_plot.react();
        } else {
            this.mock_plot = Plotly.newPlot('run_plot', null, layout);
        }

        // run_plotter = Plotly.newPlot( document.getElementById('run_plot'), ,layout);
    } else {

        let worker = new Worker("./Scripts/workers/interpreter_plot_run.js");
        worker.postMessage({ simulations: this.simulations, simulation_dataset: this.simulation_dataset, initialized_profiles: this.initialized_profiles });
        let datasets;//to store the result of the worker
        worker.onmessage = function (event) {
            datasets = event.data.datasets;
            //console.log(datasets);
            //we get the simulation object
            if (run_plot != null) {
                this.run_plot = Plotly.react('run_plot', datasets, { title: 'Simulation ' + event.data.simulations[0] + ' Run Results', showlegend: true, yaxis: { range: [0, 1.2], title: { text: 'Profile State (1= Run)' } }, xaxis: { range: [1, event.data.simulation_dataset[event.data.simulations[0]].time_initialization], title: { text: 'Simulation time (Seconds)' } } }, { scrollZoom: true, editable: true });
            } else {
                this.run_plot = Plotly.react('run_plot', datasets, { title: 'Simulation ' + event.data.simulations[0] + ' Run Results', showlegend: true, yaxis: { range: [0, 1.2], title: { text: 'Profile State (1= Run)' } }, xaxis: { range: [1, event.data.simulation_dataset[event.data.simulations[0]].time_initialization], title: { text: 'Simulation time (Seconds)' } } }, { scrollZoom: true, editable: true });
            }

        };



    }
}





//--------Test cases--------
// Refer to the documentation